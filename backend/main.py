from typing import List

from bson import ObjectId
from bson.errors import InvalidId
from fastapi import FastAPI, HTTPException, Depends

from database import get_client_collection, get_prospect_collection
from model import Client, Prospect

app = FastAPI()


# Root endpoint
@app.get("/")
async def root():
    return {"message": "Hello world"}


def parse_object_id(str_id: str) -> ObjectId:
    try:
        return ObjectId(str_id)
    except (InvalidId, TypeError, ValueError):
        raise HTTPException(status_code=400, detail="Invalid Object ID format")


# Client Endpoints
@app.post("/clients/", response_model=Client)
async def create_client(client: Client, clients=Depends(get_client_collection)):
    client_dict = client.dict(by_alias=True)
    # Do not include the 'id' key if it's None or not provided
    client_dict.pop("id", None)
    new_client = await clients.insert_one(client_dict)
    # Fetch the newly created client using the automatically generated '_id'
    created_client = await clients.find_one({"_id": new_client.inserted_id})
    # Convert the '_id' from ObjectId to string for the response
    created_client["id"] = str(created_client["_id"])
    return created_client


# Modify the list_clients function to convert the '_id' field to 'id' and ensure it is a string
@app.get("/clients/", response_model=List[Client])
async def list_clients(clients=Depends(get_client_collection)):
    clients_cursor = clients.find()
    clients_list = await clients_cursor.to_list(length=100)
    response_clients_list = [
        Client(id=str(client['_id']), **client) for client in clients_list
    ]
    return response_clients_list


@app.get("/clients/", response_model=List[Client])
async def list_clients(clients=Depends(get_client_collection)):
    clients_cursor = clients.find()
    clients_list = await clients_cursor.to_list(length=100)
    return [Client(**client) for client in clients_list]


@app.post("/prospects/", response_model=Prospect)
async def create_prospect(prospect: Prospect, prospects=Depends(get_prospect_collection),
                          clients=Depends(get_client_collection)):
    # Validate 'client_id' by attempting to convert it to ObjectId
    if not ObjectId.is_valid(prospect.client_id):
        raise HTTPException(status_code=400, detail="Invalid 'client_id' format")

    # Check if the client exists
    if not await clients.find_one({"_id": ObjectId(prospect.client_id)}):
        raise HTTPException(status_code=404, detail="Client not found")

    # Convert to dict and remove 'id' since it will be generated by MongoDB
    prospect_dict = prospect.dict(by_alias=True)
    prospect_dict.pop("id", None)

    # Insert the prospect into the database
    new_prospect = await prospects.insert_one(prospect_dict)
    created_prospect = await prospects.find_one({"_id": new_prospect.inserted_id})

    # Convert '_id' to string in the response
    created_prospect["id"] = str(created_prospect["_id"])

    return created_prospect


@app.get("/clients/{client_id}/prospects/", response_model=List[Prospect])
async def list_prospects(client_id: str, prospects=Depends(get_prospect_collection)):
    # Fetch the prospects from the database
    prospects_cursor = prospects.find({"client_id": client_id})
    prospects_list = await prospects_cursor.to_list(length=100)

    # Transform the documents before returning
    transformed_prospects = []
    for prospect_doc in prospects_list:
        # Convert ObjectId to string and create a dict for the response
        prospect_doc['id'] = str(prospect_doc.pop('_id', None))  # Transform _id to id and ensure it's a string
        transformed_prospects.append(prospect_doc)  # Add the transformed doc to the response list

    # Return the transformed list of prospects
    return transformed_prospects

