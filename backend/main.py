from typing import List

from bson import ObjectId
from bson.errors import InvalidId
from fastapi import FastAPI, HTTPException, Depends

from database import get_client_collection, get_prospect_collection
from model import Client, Prospect

app = FastAPI()


# Root endpoint
@app.get("/")
async def root():
    return {"message": "Hello world"}


def parse_object_id(str_id: str) -> ObjectId:
    try:
        return ObjectId(str_id)
    except (InvalidId, TypeError, ValueError):
        raise HTTPException(status_code=400, detail="Invalid Object ID format")


# Client Endpoints
@app.post("/clients/", response_model=Client)
async def create_client(client: Client, clients=Depends(get_client_collection)):
    client_dict = client.dict(by_alias=True)
    # Do not include the 'id' key if it's None or not provided
    client_dict.pop("id", None)
    new_client = await clients.insert_one(client_dict)
    # Fetch the newly created client using the automatically generated '_id'
    created_client = await clients.find_one({"_id": new_client.inserted_id})
    # Convert the '_id' from ObjectId to string for the response
    created_client["id"] = str(created_client["_id"])
    return created_client


# Modify the list_clients function to convert the '_id' field to 'id' and ensure it is a string
@app.get("/clients/", response_model=List[Client])
async def list_clients(clients=Depends(get_client_collection)):
    # Fetch the clients from the database and convert them to a list
    clients_cursor = clients.find()
    clients_list = await clients_cursor.to_list(length=100)

    # Create a new list for the response
    response_clients_list = []
    for client_doc in clients_list:
        # Convert ObjectId to string and create a dict for the response
        client_dict = {
            "id": str(client_doc["_id"]),
            "first_name": client_doc["first_name"],
            "last_name": client_doc["last_name"],
            "client_position": client_doc["client_position"],
            "company": client_doc["company"],
            "created_at": client_doc["created_at"],
            "additional_info": client_doc["additional_info"],
            "sl_analytics": client_doc["sl_analytics"],
        }
        # Append the client dict to the response list
        response_clients_list.append(client_dict)

    # Return the response list
    return response_clients_list


@app.get("/clients/{client_id}/", response_model=Client)
async def get_client(client_id: str, clients=Depends(get_client_collection)):
    _id = parse_object_id(client_id)
    client = await clients.find_one({"_id": _id})
    if client:
        return client
    raise HTTPException(status_code=404, detail="Client not found")


@app.post("/prospects/", response_model=Prospect)
async def create_prospect(prospect: Prospect, prospects=Depends(get_prospect_collection),
                          clients=Depends(get_client_collection)):
    # Validate 'client_id' by attempting to convert it to ObjectId
    if not ObjectId.is_valid(prospect.client_id):
        raise HTTPException(status_code=400, detail="Invalid 'client_id' format")

    # Check if the client exists
    if not await clients.find_one({"_id": ObjectId(prospect.client_id)}):
        raise HTTPException(status_code=404, detail="Client not found")

    # Convert to dict and remove 'id' since it will be generated by MongoDB
    prospect_dict = prospect.dict(by_alias=True)
    prospect_dict.pop("id", None)

    # Insert the prospect into the database
    new_prospect = await prospects.insert_one(prospect_dict)
    created_prospect = await prospects.find_one({"_id": new_prospect.inserted_id})

    # Convert '_id' to string in the response
    created_prospect["id"] = str(created_prospect["_id"])

    return created_prospect


@app.get("/clients/{client_id}/prospects/", response_model=List[Prospect])
async def list_prospects(client_id: str, prospects=Depends(get_prospect_collection)):
    return await prospects.find({"client_id": client_id}).to_list(100)
